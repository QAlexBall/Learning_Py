 ### 异步IO
**当代码需要执行一个耗时的IO操作时,**
**它只发出IO指令,并不等待IO结果,然后就去执行其他代码,**
**一段时间后,当IO返回结果时,再通知CPU进行处理**

如果按普通顺序写出的代码实际上是没法完成异步IO的:
```python
def_some_code()
f = open('/path/to/file', 'r')
r = f.read() # <== 线程停在此处等待IO操作结果
# IO操作完成后线程才能继续执行
def_some_code(r)
```
所以同步IO模型的代码是无法实现异步IO模型的
**异步IO模型需要一个消息循环,在消息循环中,**
**主线程不断重复"读取消息-处理消息"这一过程**
```python
loop = get_event_loop()
while True:
	event = loop.get_evnet()
	process_event(event)
```
消息模型早在桌面应用程序中使用,一个GUI的主线程就负责不停地读取消息并处理消息.所有的键盘鼠标等消息都被发送到GUI程序的消息队列中,然后由GUI程序的主线程处理.

# 消息模型是如何解决同步IO必须等待IO操作这一问题?
当遇到IO操作时,代码只负责发出IO请求,不等待IO结果,然后直接结束本轮消息处理,进入下一轮消息处理过程.当IO操作完成后,将收到一条"IO完成"的消息,处理该消息时就可以直接获取IO操作结果.
在"发出IO请求"到收到"IO完成"的这段时间里,同步IO模型下,主线程只能挂起,但异步IO模型下,主线程没有休息,而是在消息循环中继续处理其他消息.这样,在异步IO模型下,一个线程就可以同时处理多个IO请求,并且没有切换线程的操作.对于大多数IO密集型的应用程序,使用异步IO将大大提升系统的多任务处理能力.

